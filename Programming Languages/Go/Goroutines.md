# Goroutines em Go

## Introdução

As Goroutines são uma das características mais poderosas e essenciais da linguagem Go, oferecendo suporte para concorrência de forma leve e eficiente. Elas permitem que funções sejam executadas de forma assíncrona, sem a complexidade associada à manipulação de threads do sistema operacional.

## O que é uma Goroutine?

Uma **goroutine** é uma função executada de forma concorrente, ou seja, ao mesmo tempo que outras goroutines. Elas são muito leves em comparação às threads convencionais, ocupando menos espaço na memória e sendo gerenciadas diretamente pelo runtime da linguagem Go.

### Sintaxe básica

Para criar uma goroutine, basta colocar a palavra-chave `go` antes de uma função ou chamada de função.

```go
package main

import (
    "fmt"
    "time"
)

func sayHello() {
    fmt.Println("Hello!")
}

func main() {
    go sayHello()  // Iniciando uma goroutine
    time.Sleep(1 * time.Second)  // Pausa para permitir que a goroutine execute
}
```

No exemplo acima, a função `sayHello()` será executada de forma assíncrona. A função principal (main) não vai esperar a goroutine terminar a execução. Como o programa principal (main) pode terminar antes que a goroutine finalize, usamos `time.Sleep()` para dar tempo à goroutine.

---

## Goroutines vs Threads

Goroutines não são equivalentes diretos às threads do sistema operacional. Elas são mais leves e são multiplexadas em um número menor de threads reais pelo runtime de Go.

- **Uso de memória**: As goroutines começam com uma pilha muito pequena (cerca de 2KB), que pode crescer e diminuir conforme necessário, enquanto as threads geralmente começam com uma pilha fixa (2MB em alguns sistemas).
- **Mudança de contexto**: Como as goroutines são gerenciadas pelo runtime de Go, a mudança de contexto entre goroutines é mais eficiente do que entre threads.
- **Número**: É comum criar milhares ou até milhões de goroutines sem problemas de desempenho, algo inviável com threads nativas.

---

## Canais (Channels)

Goroutines por si só são concorrentes, mas precisamos de um meio para comunicar e sincronizar dados entre elas. Go fornece **canais (channels)** para isso.

### Criando um canal

Um canal é criado usando a função `make` e especificando o tipo de dado que ele transportará.

```go
ch := make(chan int)  // Canal para enviar e receber inteiros
```

### Enviando e recebendo dados em canais

Os operadores `<-` são usados para enviar e receber dados de um canal.

```go
package main

import "fmt"

func sayHello(ch chan string) {
    ch <- "Hello!"  // Enviando dado para o canal
}

func main() {
    ch := make(chan string)

    go sayHello(ch)  // Executando a goroutine

    message := <-ch  // Recebendo dado do canal
    fmt.Println(message)
}
```

### Canais bufferizados

Canais também podem ser **bufferizados**, permitindo o envio de múltiplos dados antes que sejam lidos. Ao criar um canal, você pode especificar o tamanho do buffer.

```go
ch := make(chan int, 2)  // Canal bufferizado com capacidade de 2
```

### Fechando um canal

Após enviar todos os dados necessários, é uma boa prática **fechar o canal** para indicar que não há mais dados para serem enviados.

```go
close(ch)
```

---

## Concorrência com WaitGroup

Às vezes, você quer garantir que o programa principal espere até que todas as goroutines sejam concluídas antes de continuar ou finalizar. O pacote `sync` fornece um recurso chamado `WaitGroup` para isso.

### Exemplo com WaitGroup

```go
package main

import (
    "fmt"
    "sync"
)

func sayHello(wg *sync.WaitGroup) {
    defer wg.Done()  // Marca como concluído
    fmt.Println("Hello!")
}

func main() {
    var wg sync.WaitGroup

    wg.Add(2)  // Adiciona o número de goroutines a serem aguardadas

    go sayHello(&wg)
    go sayHello(&wg)

    wg.Wait()  // Aguarda até que todas as goroutines sejam concluídas
}
```

Aqui, o `WaitGroup` coordena duas goroutines. A função `wg.Add(2)` indica que duas goroutines serão executadas, e a função `wg.Wait()` bloqueia até que todas elas chamem `wg.Done()`.

---

## Boas Práticas

1. **Evite goroutines sem supervisão**: Se criar goroutines que não têm como ser sincronizadas, você pode acabar com goroutines "perdidas" que nunca são finalizadas.
2. **Use canais para comunicação segura**: Use canais para enviar e receber dados entre goroutines de maneira segura e evitar condições de corrida.
3. **Limite o uso de goroutines**: Embora goroutines sejam leves, criar milhares delas de forma indiscriminada pode causar problemas de desempenho ou esgotar recursos do sistema.
4. **Use contexto para cancelamento**: O pacote `context` fornece uma maneira de cancelar goroutines quando necessário. Isso é útil em cenários de longas execuções ou sistemas distribuídos.

---

## Exemplo Completo: Multiplicação de Números Paralelamente

Aqui está um exemplo mais complexo que usa goroutines e canais para realizar cálculos de forma concorrente.

```go
package main

import (
    "fmt"
    "sync"
)

func multiplyByTwo(number int, ch chan int, wg *sync.WaitGroup) {
    defer wg.Done()
    ch <- number * 2
}

func main() {
    numbers := []int{1, 2, 3, 4, 5}
    ch := make(chan int)
    var wg sync.WaitGroup

    for _, num := range numbers {
        wg.Add(1)
        go multiplyByTwo(num, ch, &wg)
    }

    go func() {
        wg.Wait()
        close(ch)
    }()

    for result := range ch {
        fmt.Println(result)
    }
}
```

Neste exemplo, multiplicamos cada número da lista `numbers` por 2 usando goroutines. Os resultados são enviados para um canal e processados conforme as goroutines são concluídas.

---

## Conclusão

Goroutines tornam o uso de concorrência em Go extremamente eficiente e simples, permitindo que você crie programas altamente paralelos sem lidar com a complexidade de threads convencionais. Canais fornecem uma maneira segura de sincronizar goroutines, e o uso de `WaitGroup` e `context` pode ajudar a evitar problemas comuns em programação concorrente.

Compreender goroutines e canais é fundamental para escrever programas robustos em Go.