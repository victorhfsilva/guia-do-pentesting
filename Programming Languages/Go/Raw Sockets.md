# Raw Sockets em Go

Os **Raw Sockets** (sockets brutos) permitem o envio e recebimento de pacotes de rede diretamente no nível de rede, sem qualquer tipo de processamento adicional por parte do sistema operacional. Em Go, lidar com raw sockets exige um entendimento mais profundo sobre protocolos de rede, e, como o suporte direto para raw sockets não está disponível no pacote `net`, precisamos usar bibliotecas externas ou interagir diretamente com chamadas do sistema.

Este guia abordará o que são raw sockets, como configurá-los e utilizá-los em Go com exemplos práticos.

### **O Que São Raw Sockets?**

Raw sockets permitem que você crie pacotes de rede manualmente, o que significa que você pode construir seu próprio cabeçalho de protocolo de rede (como IP, TCP, ou ICMP) e enviar diretamente os pacotes. Esse nível de controle é útil para:

- Ferramentas de diagnóstico de rede, como ping ou traceroute.
- Testes de penetração (ferramentas como scanners de portas).
- Implementação de protocolos de rede customizados.

No entanto, nem todos os sistemas operacionais permitem o uso de raw sockets sem privilégios de superusuário, devido a questões de segurança.

### **Trabalhando com Raw Sockets em Go**

Como Go não fornece suporte nativo para raw sockets no pacote `net`, podemos usar a chamada de sistema `syscall` para criar raw sockets diretamente. Além disso, é comum usar pacotes externos como [`golang.org/x/net/ipv4`](https://pkg.go.dev/golang.org/x/net/ipv4) para facilitar a manipulação de pacotes no nível IP.

A seguir está um exemplo simples de como abrir e enviar pacotes usando raw sockets em Go.

### **Exemplo de Raw Socket para Enviar um Pacote ICMP (Ping)**

O **protocolo ICMP** é comumente usado para enviar pacotes de "ping", e com raw sockets, podemos criar manualmente esses pacotes. Vamos criar um programa que envia um pacote ICMP e recebe a resposta.

#### Exemplo:

```go
package main

import (
    "encoding/binary"
    "fmt"
    "log"
    "net"
    "os"
    "syscall"
    "time"
)

const (
    ICMP_ECHO_REQUEST = 8  // Tipo de mensagem ICMP para ping
    ICMP_ECHO_REPLY   = 0  // Resposta de ping
)

// Estrutura do cabeçalho ICMP
type icmpHeader struct {
    Type     uint8
    Code     uint8
    Checksum uint16
    ID       uint16
    Seq      uint16
}

// Função para calcular o checksum
func checksum(data []byte) uint16 {
    var sum uint32
    for i := 0; i < len(data)-1; i += 2 {
        sum += uint32(data[i])<<8 | uint32(data[i+1])
    }
    if len(data)%2 == 1 {
        sum += uint32(data[len(data)-1]) << 8
    }
    sum = (sum >> 16) + (sum & 0xffff)
    sum += sum >> 16
    return uint16(^sum)
}

// Função para criar um pacote ICMP
func createICMPPacket(seq uint16) []byte {
    icmp := icmpHeader{
        Type: ICMP_ECHO_REQUEST,
        Code: 0,
        ID:   uint16(os.Getpid() & 0xffff), // Usamos o PID como ID
        Seq:  seq,
    }

    // Criar o pacote ICMP
    packet := make([]byte, 8)
    binary.BigEndian.PutUint16(packet[4:], icmp.ID)
    binary.BigEndian.PutUint16(packet[6:], icmp.Seq)

    // Calcular o checksum
    icmp.Checksum = checksum(packet)
    binary.BigEndian.PutUint16(packet[2:], icmp.Checksum)

    return packet
}

func main() {
    if len(os.Args) != 2 {
        fmt.Println("Uso: go run main.go <endereço>")
        return
    }

    target := os.Args[1]

    // Resolve o endereço IP do alvo
    ipAddr, err := net.ResolveIPAddr("ip4", target)
    if err != nil {
        log.Fatalf("Erro ao resolver o endereço: %v", err)
    }

    // Criar um socket raw (ICMP)
    sock, err := syscall.Socket(syscall.AF_INET, syscall.SOCK_RAW, syscall.IPPROTO_ICMP)
    if err != nil {
        log.Fatalf("Erro ao criar socket: %v", err)
    }
    defer syscall.Close(sock)

    // Criar o endereço do destino
    addr := syscall.SockaddrInet4{
        Port: 0,
    }
    copy(addr.Addr[:], ipAddr.IP.To4())

    // Criar o pacote ICMP
    seq := uint16(1)
    packet := createICMPPacket(seq)

    // Enviar o pacote ICMP
    if err := syscall.Sendto(sock, packet, 0, &addr); err != nil {
        log.Fatalf("Erro ao enviar pacote: %v", err)
    }
    fmt.Printf("Ping enviado para %s\n", target)

    // Esperar pela resposta ICMP
    recvBuffer := make([]byte, 1024)
    syscall.SetNonblock(sock, false)

    n, _, err := syscall.Recvfrom(sock, recvBuffer, 0)
    if err != nil {
        log.Fatalf("Erro ao receber resposta: %v", err)
    }

    // Verifica se o pacote recebido é uma resposta ICMP
    icmpReply := recvBuffer[20:n] // Ignora o cabeçalho IP (20 bytes)
    icmpType := icmpReply[0]

    if icmpType == ICMP_ECHO_REPLY {
        fmt.Println("Resposta de ping recebida!")
    } else {
        fmt.Println("Resposta inesperada")
    }

    time.Sleep(1 * time.Second)
}
```

### **Explicação do Código**

####  **Cabeçalho ICMP**

No exemplo acima, construímos um cabeçalho ICMP manualmente, que é composto por:

- **Type**: O tipo de mensagem ICMP (8 para echo request e 0 para echo reply).
- **Code**: Um código que especifica o tipo de erro (neste caso, 0).
- **Checksum**: Usado para verificar a integridade do pacote.
- **ID e Seq**: Usados para identificar e rastrear o pacote.

#### **Criação do Socket**

A função `syscall.Socket` cria um socket bruto com o protocolo ICMP. Note que você precisará de privilégios de superusuário para criar um raw socket.

#### **Envio do Pacote**

A função `syscall.Sendto` é usada para enviar o pacote ICMP para o endereço de destino. O pacote é enviado diretamente ao nível IP, sem interferência do sistema operacional.

#### **Recebendo a Resposta**

Após enviar o pacote, o programa espera uma resposta utilizando `syscall.Recvfrom`. A resposta é verificada para ver se o tipo ICMP é 0 (echo reply), o que indica que o ping foi bem-sucedido.

### **Execução**

Para rodar este programa, é necessário ter privilégios elevados. No Linux ou macOS, execute o programa com `sudo`:

```bash
sudo go run main.go <endereço-alvo>
```

Isso enviará um pacote de ping para o destino e esperará pela resposta.

### **Considerações de Segurança**

Os raw sockets permitem controle completo sobre a construção e envio de pacotes, o que os torna poderosos, mas também perigosos. Usá-los incorretamente pode levar a vulnerabilidades de segurança ou comportamentos inesperados na rede. Muitos sistemas operacionais limitam o uso de raw sockets a programas rodando com privilégios de superusuário por esse motivo.

### Conclusão

Trabalhar com raw sockets em Go requer um bom entendimento de redes e das estruturas de protocolos, além de permissões adequadas no sistema operacional. Embora Go não forneça suporte nativo para raw sockets no pacote padrão, com o uso do pacote `syscall` é possível criar e manipular pacotes brutos para protocolos como ICMP, permitindo a construção de ferramentas avançadas de rede, como programas de ping, traceroute e scanners de portas.