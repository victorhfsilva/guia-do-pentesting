# Sockets em Go

Go oferece suporte robusto para trabalhar com sockets através do pacote `net`, o que permite criar aplicações de rede tanto para comunicação TCP quanto UDP. Este guia explora como implementar servidores e clientes utilizando sockets TCP e UDP em Go, abrangendo os conceitos principais e exemplos de código.

### **O Pacote `net`**

O pacote `net` contém funções e tipos para trabalhar com conexões de rede, incluindo TCP, UDP e mais. Este pacote fornece a funcionalidade para abrir, aceitar, ler e escrever dados em sockets.

### **Trabalhando com Sockets TCP**

#### **Servidor TCP**

Um servidor TCP em Go normalmente envolve:

1. Abrir um socket que "ouve" em uma porta específica (`net.Listen`).
2. Aceitar conexões de clientes (`listener.Accept`).
3. Ler e escrever dados na conexão (`conn.Read` e `conn.Write`).

Aqui está um exemplo básico de servidor TCP:

```go
package main

import (
    "fmt"
    "net"
)

func main() {
    // Cria um socket que escuta na porta 8080
    listener, err := net.Listen("tcp", ":8080")
    if err != nil {
        fmt.Println("Erro ao iniciar o servidor:", err)
        return
    }
    defer listener.Close()
    fmt.Println("Servidor TCP rodando na porta 8080...")

    for {
        // Aceita uma nova conexão de cliente
        conn, err := listener.Accept()
        if err != nil {
            fmt.Println("Erro ao aceitar conexão:", err)
            continue
        }
        go handleConnection(conn) // Trata cada conexão em uma nova goroutine
    }
}

func handleConnection(conn net.Conn) {
    defer conn.Close()
    buffer := make([]byte, 1024)
    
    // Lê dados enviados pelo cliente
    n, err := conn.Read(buffer)
    if err != nil {
        fmt.Println("Erro ao ler dados:", err)
        return
    }

    fmt.Printf("Mensagem recebida: %s\n", string(buffer[:n]))

    // Envia uma resposta ao cliente
    conn.Write([]byte("Mensagem recebida!\n"))
}
```

#### **Cliente TCP**

Um cliente TCP em Go se conecta a um servidor e pode enviar e receber dados. O cliente usa `net.Dial` para se conectar ao servidor.

Exemplo de cliente TCP:

```go
package main

import (
    "fmt"
    "net"
)

func main() {
    // Conecta-se ao servidor TCP na porta 8080
    conn, err := net.Dial("tcp", "localhost:8080")
    if err != nil {
        fmt.Println("Erro ao conectar ao servidor:", err)
        return
    }
    defer conn.Close()

    // Envia uma mensagem ao servidor
    message := "Olá, servidor!"
    conn.Write([]byte(message))

    // Lê a resposta do servidor
    buffer := make([]byte, 1024)
    n, err := conn.Read(buffer)
    if err != nil {
        fmt.Println("Erro ao ler resposta:", err)
        return
    }
    fmt.Printf("Resposta do servidor: %s\n", string(buffer[:n]))
}
```

### **Trabalhando com Sockets UDP**

O protocolo UDP é diferente do TCP porque não estabelece uma conexão antes de enviar dados. Os dados são enviados em "datagramas", o que torna o UDP mais rápido, mas menos confiável. A implementação de sockets UDP em Go usa `net.PacketConn`.

#### **Servidor UDP**

Aqui está um exemplo básico de servidor UDP:

```go
package main

import (
    "fmt"
    "net"
)

func main() {
    // Cria um socket UDP que escuta na porta 8081
    addr := net.UDPAddr{
        Port: 8081,
        IP:   net.ParseIP("127.0.0.1"),
    }

    conn, err := net.ListenUDP("udp", &addr)
    if err != nil {
        fmt.Println("Erro ao iniciar servidor UDP:", err)
        return
    }
    defer conn.Close()
    fmt.Println("Servidor UDP rodando na porta 8081...")

    buffer := make([]byte, 1024)
    for {
        // Lê datagramas enviados pelos clientes
        n, addr, err := conn.ReadFromUDP(buffer)
        if err != nil {
            fmt.Println("Erro ao ler datagrama:", err)
            continue
        }

        fmt.Printf("Mensagem de %s: %s\n", addr, string(buffer[:n]))

        // Responde ao cliente
        _, err = conn.WriteToUDP([]byte("Mensagem recebida!\n"), addr)
        if err != nil {
            fmt.Println("Erro ao enviar resposta:", err)
        }
    }
}
```

#### **Cliente UDP**

O cliente UDP envia datagramas diretamente ao servidor sem estabelecer uma conexão persistente.

Exemplo de cliente UDP:

```go
package main

import (
    "fmt"
    "net"
)

func main() {
    // Conecta-se ao servidor UDP
    addr := net.UDPAddr{
        Port: 8081,
        IP:   net.ParseIP("127.0.0.1"),
    }
    
    conn, err := net.DialUDP("udp", nil, &addr)
    if err != nil {
        fmt.Println("Erro ao conectar ao servidor UDP:", err)
        return
    }
    defer conn.Close()

    // Envia uma mensagem ao servidor
    message := []byte("Olá, servidor UDP!")
    _, err = conn.Write(message)
    if err != nil {
        fmt.Println("Erro ao enviar mensagem:", err)
        return
    }

    // Lê a resposta do servidor
    buffer := make([]byte, 1024)
    n, _, err := conn.ReadFromUDP(buffer)
    if err != nil {
        fmt.Println("Erro ao ler resposta:", err)
        return
    }
    fmt.Printf("Resposta do servidor: %s\n", string(buffer[:n]))
}
```

### 4. **Conceitos Importantes**

- **Goroutines**: No exemplo de servidor TCP, cada conexão é tratada em uma goroutine separada usando `go handleConnection(conn)`. Isso permite que o servidor lide com várias conexões de forma concorrente.
  
- **Conexão vs. Não-Conexão**: No TCP, é estabelecida uma conexão entre cliente e servidor, garantindo a entrega dos dados. No UDP, os pacotes são enviados sem conexão, tornando-o mais rápido, mas menos confiável.

- **Leitura e Escrita**: Tanto em TCP quanto em UDP, a leitura e escrita são realizadas usando métodos como `Read`, `Write`, `ReadFromUDP` e `WriteToUDP`.

### **Tratamento de Erros e Encerramento de Conexões**

É fundamental lidar corretamente com erros, tanto no cliente quanto no servidor, e encerrar conexões (usando `defer conn.Close()`), especialmente em servidores TCP, onde várias conexões podem ser estabelecidas.

