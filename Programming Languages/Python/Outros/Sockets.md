# Sockets em Python

Os **sockets** são um mecanismo fundamental para a comunicação entre dispositivos em uma rede. Em Python, a biblioteca padrão `socket` fornece uma interface para trabalhar com sockets, permitindo a criação de programas que podem se comunicar através da rede (como clientes e servidores). Este guia oferece uma visão geral sobre o uso de sockets em Python, com exemplos práticos.

### **O que é um Socket?**

Um **socket** é um ponto final de uma comunicação bidirecional entre dois programas executados em uma rede. Em redes baseadas no protocolo IP (como a Internet), um socket é identificado por dois elementos:
- O **endereço IP** do dispositivo.
- O **número da porta**, que é um identificador de qual serviço ou aplicação deseja se comunicar.

### **Criando um Socket em Python**

Em Python, para criar um socket, usamos a biblioteca `socket`. A função `socket()` cria um objeto de socket, que pode ser configurado para se conectar a um servidor (cliente) ou para escutar conexões de clientes (servidor).

#### Exemplo básico de criação de socket:
```python
import socket

# Criar um socket TCP/IPv4
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
```

Aqui, usamos:
- `socket.AF_INET`: Indica que o socket usará o protocolo IPv4.
- `socket.SOCK_STREAM`: Especifica que usaremos TCP (transmissão orientada à conexão). Para UDP, usaríamos `socket.SOCK_DGRAM`.

### **Cliente e Servidor com Sockets**

####  **Servidor Socket**

Um servidor socket é um programa que fica esperando por conexões de clientes e, quando recebe uma conexão, pode trocar dados com eles. O ciclo básico de um servidor socket é o seguinte:
1. Criar o socket.
2. Associá-lo a um endereço IP e porta.
3. Colocar o socket em modo de escuta (`listen`).
4. Aceitar conexões de clientes.
5. Trocar dados com o cliente.
6. Fechar a conexão.

Aqui está um exemplo básico de servidor TCP:

**Exemplo de Servidor TCP:**
```python
import socket

# Criação do socket
servidor = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# Vincula o socket ao endereço IP e porta
servidor.bind(('localhost', 12345))

# Coloca o servidor em modo de escuta (aceitando conexões)
servidor.listen(5)
print("Servidor esperando por conexões...")

while True:
    # Aceitar uma conexão
    cliente, endereco = servidor.accept()
    print(f"Conexão estabelecida com {endereco}")

    # Enviar uma mensagem para o cliente
    mensagem = "Bem-vindo ao servidor!"
    cliente.send(mensagem.encode('utf-8'))

    # Receber dados do cliente
    dados = cliente.recv(1024).decode('utf-8')
    print(f"Mensagem recebida do cliente: {dados}")

    # Encerrar a conexão com o cliente
    cliente.close()
```

#### Explicação:
- `bind(('localhost', 12345))`: Vincula o servidor ao endereço `localhost` e à porta `12345`.
- `listen(5)`: Coloca o socket em modo de escuta, permitindo até 5 conexões pendentes.
- `accept()`: Espera até que um cliente tente se conectar, e então aceita a conexão.
- `send()`: Envia dados para o cliente.
- `recv()`: Recebe dados do cliente.

#### **Cliente Socket**

O cliente socket se conecta ao servidor e envia ou recebe dados. O ciclo básico de um cliente socket é:
1. Criar o socket.
2. Conectar-se ao servidor.
3. Enviar e/ou receber dados.
4. Fechar a conexão.

**Exemplo de Cliente TCP:**
```python
import socket

# Criar um socket para o cliente
cliente = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# Conectar ao servidor (usando o endereço IP e porta)
cliente.connect(('localhost', 12345))

# Receber mensagem do servidor
mensagem = cliente.recv(1024).decode('utf-8')
print(f"Mensagem do servidor: {mensagem}")

# Enviar uma mensagem ao servidor
cliente.send("Olá, servidor!".encode('utf-8'))

# Fechar a conexão
cliente.close()
```

#### Explicação:
- `connect(('localhost', 12345))`: Conecta o cliente ao servidor no endereço `localhost` e na porta `12345`.
- `recv(1024)`: Recebe até 1024 bytes de dados do servidor.

### **Sockets UDP**

Diferente do TCP, que é orientado à conexão, o **UDP (User Datagram Protocol)** é um protocolo sem conexão. Ele envia pacotes de dados (datagramas) sem garantir que eles chegarão ao destino ou que serão recebidos na ordem correta.

#### **Servidor UDP:**
```python
import socket

# Criar o socket UDP
servidor = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# Vincular o socket ao endereço e porta
servidor.bind(('localhost', 12345))

print("Servidor UDP esperando por mensagens...")

while True:
    # Receber dados de um cliente (datagrama)
    dados, endereco = servidor.recvfrom(1024)
    print(f"Mensagem recebida de {endereco}: {dados.decode('utf-8')}")

    # Enviar uma resposta ao cliente
    servidor.sendto("Mensagem recebida!".encode('utf-8'), endereco)
```

#### **Cliente UDP:**
```python
import socket

# Criar o socket UDP
cliente = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# Enviar mensagem ao servidor
mensagem = "Olá, servidor UDP!"
cliente.sendto(mensagem.encode('utf-8'), ('localhost', 12345))

# Receber resposta do servidor
dados, servidor = cliente.recvfrom(1024)
print(f"Resposta do servidor: {dados.decode('utf-8')}")

# Fechar o socket
cliente.close()
```

### **Tratando Exceções e Timeout**

Como a comunicação de rede pode falhar (por exemplo, o servidor pode não estar acessível ou a conexão pode ser interrompida), é importante tratar exceções e definir um timeout (tempo limite) para os sockets.

#### Exemplo de tratamento de exceções e timeout:
```python
import socket

try:
    # Criar o socket
    cliente = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    
    # Definir um tempo limite para a conexão
    cliente.settimeout(5)  # 5 segundos
    
    # Tentar conectar ao servidor
    cliente.connect(('localhost', 12345))
    
    # Enviar dados
    cliente.send("Teste de timeout".encode('utf-8'))

    # Receber resposta
    resposta = cliente.recv(1024).decode('utf-8')
    print("Resposta do servidor:", resposta)

except socket.timeout:
    print("A conexão expirou.")
    
except socket.error as e:
    print(f"Erro de socket: {e}")

finally:
    # Fechar a conexão
    cliente.close()
```

### **Comunicação Bidirecional e Persistente**

Para manter uma comunicação bidirecional (envio e recebimento contínuos de dados) ou persistente (manter a conexão aberta por mais tempo), você pode criar um loop de envio e recepção de dados no cliente e no servidor.

**Exemplo:**
```python
import socket

# Servidor
servidor = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
servidor.bind(('localhost', 12345))
servidor.listen(5)

cliente, endereco = servidor.accept()

while True:
    # Recebe mensagem do cliente
    dados = cliente.recv(1024).decode('utf-8')
    if not dados:
        break  # Se não houver dados, encerra a conexão
    print(f"Cliente: {dados}")
    
    # Envia resposta ao cliente
    cliente.send("Mensagem recebida!".encode('utf-8'))

cliente.close()
```
