# Guia sobre Alocação Dinâmica de Memória em C

## Introdução

Em C, a **alocação dinâmica de memória** permite que um programa reserve memória em tempo de execução, ao invés de tempo de compilação. Isso é particularmente útil quando o tamanho necessário da memória não é conhecido antecipadamente ou quando você precisa de estruturas de dados que podem crescer ou diminuir durante a execução do programa.

Para trabalhar com alocação dinâmica, a linguagem C fornece um conjunto de funções na biblioteca padrão `<stdlib.h>`:

- `malloc`: Aloca um bloco de memória de tamanho especificado.
- `calloc`: Aloca múltiplos blocos de memória inicializados com zero.
- `realloc`: Redimensiona um bloco de memória previamente alocado.
- `free`: Libera um bloco de memória previamente alocado.

## Ponteiros e Memória Dinâmica

Antes de explorar as funções de alocação, é importante entender o papel dos **ponteiros** na memória dinâmica. Quando você aloca memória dinamicamente, as funções retornam um ponteiro para o bloco de memória alocado. Você usa esse ponteiro para acessar e manipular a memória.

### Exemplo Simples:

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int *ptr;

    // Alocando memória para um inteiro
    ptr = (int *)malloc(sizeof(int));

    if (ptr == NULL) {
        printf("Erro na alocação de memória.\n");
        exit(1);
    }

    *ptr = 100;  // Atribuindo valor à memória alocada
    printf("Valor armazenado: %d\n", *ptr);

    free(ptr);  // Liberando a memória alocada

    return 0;
}
```

**Explicação**:

- `malloc` aloca memória suficiente para armazenar um `int` e retorna um ponteiro para essa memória.
- Verificamos se `ptr` é `NULL` para assegurar que a alocação foi bem-sucedida.
- Usamos `*ptr` para acessar o valor armazenado na memória alocada.
- Finalmente, usamos `free` para liberar a memória.

## Funções de Alocação de Memória

### `malloc` (Memory Allocation)

A função `malloc` aloca um bloco de memória contígua de tamanho especificado em bytes.

**Sintaxe**:

```c
void *malloc(size_t tamanho);
```

- **Parâmetro**:
  - `tamanho`: Número de bytes a serem alocados.
- **Retorno**:
  - Um ponteiro para o início do bloco de memória alocado.
  - `NULL` se a alocação falhar.

**Exemplo**:

```c
int *vetor;
vetor = (int *)malloc(10 * sizeof(int));  // Aloca um vetor de 10 inteiros
```

###  `calloc` (Contiguous Allocation)

A função `calloc` aloca memória para um número especificado de elementos de um determinado tamanho e inicializa todos os bits com zero.

**Sintaxe**:

```c
void *calloc(size_t num_elementos, size_t tamanho_elemento);
```

- **Parâmetros**:
  - `num_elementos`: Número de elementos a serem alocados.
  - `tamanho_elemento`: Tamanho de cada elemento em bytes.
- **Retorno**:
  - Um ponteiro para o início do bloco de memória alocado.
  - `NULL` se a alocação falhar.

**Exemplo**:

```c
int *vetor;
vetor = (int *)calloc(10, sizeof(int));  // Aloca e inicializa um vetor de 10 inteiros
```

### Diferenças entre `malloc` e `calloc`:

- **Inicialização**: `malloc` não inicializa a memória alocada, enquanto `calloc` inicializa todos os bits com zero.
- **Parâmetros**: `malloc` recebe o tamanho total em bytes, enquanto `calloc` recebe o número de elementos e o tamanho de cada elemento.

### `realloc` (Re-allocation)

A função `realloc` redimensiona um bloco de memória previamente alocado com `malloc`, `calloc` ou `realloc`.

**Sintaxe**:

```c
void *realloc(void *ptr, size_t novo_tamanho);
```

- **Parâmetros**:
  - `ptr`: Ponteiro para a memória previamente alocada.
  - `novo_tamanho`: Novo tamanho em bytes.
- **Retorno**:
  - Um ponteiro para o novo bloco de memória.
  - `NULL` se a alocação falhar (o ponteiro original não é liberado neste caso).

**Exemplo**:

```c
int *vetor;
vetor = (int *)malloc(5 * sizeof(int));  // Aloca um vetor de 5 inteiros

// Redimensiona o vetor para armazenar 10 inteiros
vetor = (int *)realloc(vetor, 10 * sizeof(int));
```

### `free` (Memory Deallocation)

A função `free` libera um bloco de memória previamente alocado com `malloc`, `calloc` ou `realloc`.

**Sintaxe**:

```c
void free(void *ptr);
```

- **Parâmetro**:
  - `ptr`: Ponteiro para a memória a ser liberada.

**Exemplo**:

```c
free(vetor);  // Libera a memória alocada para 'vetor'
```

## Boas Práticas com Alocação Dinâmica

### Verificação de Erros

Sempre verifique se a alocação foi bem-sucedida antes de usar a memória alocada.

**Exemplo**:

```c
int *ptr = (int *)malloc(sizeof(int));
if (ptr == NULL) {
    fprintf(stderr, "Erro: Falha na alocação de memória.\n");
    exit(EXIT_FAILURE);
}
```

### Liberar Memória

Sempre use `free` para liberar memória alocada quando não for mais necessária, evitando vazamentos de memória.

### Inicialização de Ponteiros

Após liberar a memória, é uma boa prática definir o ponteiro como `NULL` para evitar ponteiros pendentes.

**Exemplo**:

```c
free(ptr);
ptr = NULL;
```

###  Uso Correto de `realloc`

Ao usar `realloc`, é aconselhável usar um ponteiro temporário para evitar perda de dados em caso de falha na alocação.

**Exemplo**:

```c
int *temp = (int *)realloc(vetor, novo_tamanho * sizeof(int));
if (temp == NULL) {
    // Tratamento de erro
} else {
    vetor = temp;
}
```

## Exemplo Prático: Vetor de Tamanho Variável

Vamos criar um programa que lê números inteiros do usuário até que ele digite `-1`, armazenando esses números em um vetor cujo tamanho aumenta dinamicamente conforme necessário.

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int *numeros = NULL;
    int entrada;
    int tamanho = 0;

    printf("Digite números inteiros (-1 para sair):\n");
    while (1) {
        scanf("%d", &entrada);
        if (entrada == -1) {
            break;
        }

        // Redimensiona o vetor para armazenar o novo número
        int *temp = (int *)realloc(numeros, (tamanho + 1) * sizeof(int));
        if (temp == NULL) {
            printf("Erro na alocação de memória.\n");
            free(numeros);
            exit(1);
        }
        numeros = temp;

        numeros[tamanho] = entrada;
        tamanho++;
    }

    printf("Números digitados:\n");
    for (int i = 0; i < tamanho; i++) {
        printf("%d ", numeros[i]);
    }
    printf("\n");

    free(numeros);
    return 0;
}
```

**Explicação**:

- Usamos `realloc` para aumentar o tamanho do vetor a cada novo número inserido.
- Verificamos se `realloc` retornou `NULL` para tratar possíveis erros.
- Após o uso, liberamos a memória alocada com `free`.

## Alocação de Memória para Matrizes

Você pode alocar memória dinamicamente para matrizes (arrays multidimensionais).

### Matrizes Unidimensionais

Já vimos como alocar um vetor de inteiros:

```c
int *vetor = (int *)malloc(tamanho * sizeof(int));
```

### Matrizes Bidimensionais

Há várias maneiras de alocar uma matriz bidimensional dinamicamente.

**Método 1: Alocar um array de ponteiros e, em seguida, alocar um array para cada ponteiro**

```c
int **matriz;
int linhas = 5, colunas = 3;

// Aloca um array de ponteiros
matriz = (int **)malloc(linhas * sizeof(int *));
if (matriz == NULL) {
    // Tratamento de erro
}

// Aloca um array para cada linha
for (int i = 0; i < linhas; i++) {
    matriz[i] = (int *)malloc(colunas * sizeof(int));
    if (matriz[i] == NULL) {
        // Tratamento de erro
    }
}

// Uso da matriz
matriz[2][1] = 10;

// Liberando a memória
for (int i = 0; i < linhas; i++) {
    free(matriz[i]);
}
free(matriz);
```

**Método 2: Alocar um único bloco contíguo de memória**

```c
int *matriz;
int linhas = 5, colunas = 3;

matriz = (int *)malloc(linhas * colunas * sizeof(int));
if (matriz == NULL) {
    // Tratamento de erro
}

// Acessando elementos
int i = 2, j = 1;
matriz[i * colunas + j] = 10;

// Liberando a memória
free(matriz);
```

## Funções Personalizadas para Alocação

Você pode encapsular as operações de alocação em funções para facilitar o uso e melhorar a legibilidade.

**Exemplo**:

```c
void *malloc_s(size_t tamanho) {
    void *ptr = malloc(tamanho);
    if (ptr == NULL) {
        fprintf(stderr, "Erro: Falha na alocação de memória.\n");
        exit(EXIT_FAILURE);
    }
    return ptr;
}
```

Agora você pode usar `malloc_s` em vez de `malloc`, sem precisar verificar o retorno toda vez.

## Dicas e Considerações

- **Evite vazamentos de memória**: Sempre que você alocar memória com `malloc`, `calloc` ou `realloc`, certifique-se de liberar essa memória com `free` quando não for mais necessária.
- **Não acesse memória após liberar**: Depois de chamar `free`, não tente acessar o conteúdo apontado pelo ponteiro, a menos que ele seja atribuído novamente.
- **Inicialize ponteiros**: Ao declarar um ponteiro, inicialize-o com `NULL` ou com um endereço válido para evitar comportamentos indeterminados.
- **Cuidado com o uso de `realloc`**: Se `realloc` falhar, ele retorna `NULL` e o ponteiro original permanece válido. Por isso, é importante armazenar o retorno de `realloc` em um ponteiro temporário.
- **Overflow de tamanho**: Ao calcular o tamanho a ser alocado, cuidado com possíveis overflows. Use tipos `size_t` para tamanhos e multiplicações de tamanhos.



