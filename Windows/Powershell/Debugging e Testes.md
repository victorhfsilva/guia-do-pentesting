### Debugging e Testes no PowerShell

Depurar scripts e escrever testes são partes fundamentais do desenvolvimento de scripts robustos em PowerShell. A depuração ajuda a identificar problemas em tempo de execução, enquanto os testes de unidade garantem que o código funcione conforme o esperado.


### Depuração de Scripts no PowerShell

A depuração é um processo que permite a inspeção do comportamento do código enquanto ele está sendo executado. O PowerShell oferece suporte nativo à depuração por meio de breakpoints e interação em tempo real com o código.

#### Usar Breakpoints com `Set-PSBreakpoint`

Um **breakpoint** é um ponto no código onde a execução será pausada, permitindo que você inspecione variáveis, execute comandos passo a passo e observe o comportamento do script.

##### Tipos de Breakpoints:

- **Linha**: Pausa a execução em uma linha específica.
- **Variável**: Pausa quando o valor de uma variável é alterado.
- **Função**: Pausa a execução quando uma função específica é chamada.

#### Definir um Breakpoint de Linha

Você pode definir um breakpoint em uma linha específica de um script usando o cmdlet `Set-PSBreakpoint`.

##### Exemplo: Definir um breakpoint na linha 5 de um script
```powershell
Set-PSBreakpoint -Script "C:\Scripts\MeuScript.ps1" -Line 5
```

#### Depurar um Script

Após definir um breakpoint, execute o script normalmente. Quando o PowerShell atingir o breakpoint, ele pausará a execução e abrirá um prompt interativo onde você poderá inspecionar o ambiente do script.

#### Inspecionar o Estado durante a Depuração

Quando o script é interrompido em um breakpoint, você pode inspecionar variáveis e até mesmo modificar o código.

##### Comandos úteis durante a depuração:
- **`l` ou `list`**: Lista as linhas de código ao redor do breakpoint.
- **`k` ou `Get-PSCallStack`**: Exibe a pilha de chamadas (call stack).
- **`v` ou `Get-PSBreakpoint`**: Lista os breakpoints definidos.
- **`c` ou `continue`**: Continua a execução até o próximo breakpoint.
- **`s` ou `step`**: Executa uma única linha e pausa novamente.
- **`q` ou `quit`**: Sai do modo de depuração.

##### Exemplo: Inspecionar uma variável durante a depuração
```powershell
$minhaVariavel
```

#### Remover Breakpoints

Para remover breakpoints, use o cmdlet `Remove-PSBreakpoint`.

##### Exemplo:
```powershell
# Remover todos os breakpoints
Remove-PSBreakpoint -All
```

#### Definir Breakpoints por Função ou Variável

Além de breakpoints em linhas específicas, você pode definir breakpoints que pausam a execução quando uma função específica é chamada ou quando uma variável é modificada.

##### Exemplo: Breakpoint de função
```powershell
Set-PSBreakpoint -Script "C:\Scripts\MeuScript.ps1" -Command "MinhaFuncao"
```

##### Exemplo: Breakpoint de variável
```powershell
Set-PSBreakpoint -Variable "minhaVariavel"
```

---

### Testes de Unidade com Pester

O **Pester** é o framework de testes mais popular para PowerShell, usado para criar testes de unidade que validam o comportamento de funções e scripts. Escrever testes com o Pester ajuda a garantir que seu código funcione corretamente e continue funcionando conforme esperado à medida que você o modifica.

#### Instalar o Pester

O Pester é um módulo do PowerShell que pode ser instalado a partir da PowerShell Gallery.

##### Instalação do Pester:
```powershell
Install-Module -Name Pester -Force -SkipPublisherCheck
```

#### Criar um Teste de Unidade Básico

No Pester, você define seus testes dentro de blocos `Describe` e `It`. O bloco `Describe` contém uma coleção de testes relacionados, e cada bloco `It` contém um teste específico.

##### Estrutura básica de um teste Pester:
```powershell
Describe "Teste de Unidade" {
    It "Deve somar dois números corretamente" {
        $resultado = 2 + 2
        $resultado | Should -Be 4
    }
}
```

Neste exemplo, o comando `Should -Be` verifica se o resultado da expressão é igual a 4.

####  Executar Testes com Pester

Para executar testes escritos com Pester, use o cmdlet `Invoke-Pester`. Ele executa todos os testes definidos e gera um relatório com os resultados.

##### Exemplo: Executar testes de um arquivo de teste
```powershell
Invoke-Pester -Script "C:\Scripts\MeuTeste.ps1"
```

#### Testando Funções

Pester é frequentemente usado para testar funções. Vamos criar um exemplo de função e testar seu comportamento.

##### Exemplo: Função para ser testada
```powershell
function Somar-Numeros {
    param ($a, $b)
    return $a + $b
}
```

##### Exemplo de arquivo de teste para a função
```powershell
Describe "Testes da função Somar-Numeros" {
    It "Deve retornar 5 quando 2 e 3 forem somados" {
        $resultado = Somar-Numeros -a 2 -b 3
        $resultado | Should -Be 5
    }

    It "Deve retornar -1 quando 2 e -3 forem somados" {
        $resultado = Somar-Numeros -a 2 -b -3
        $resultado | Should -Be -1
    }
}
```

#### Usar Mocks em Testes

O Pester também permite o uso de **mocks**, que são substituições temporárias de comandos ou funções para testar partes específicas do código sem realmente executá-las.

##### Exemplo de uso de Mock:
```powershell
Describe "Testes com Mock" {
    Mock Get-Date { return "2024-01-01" }

    It "Deve retornar a data mockada" {
        $data = Get-Date
        $data | Should -Be "2024-01-01"
    }
}
```

Aqui, a função `Get-Date` é substituída por uma versão que sempre retorna "2024-01-01", permitindo testar o comportamento do código em um cenário controlado.

#### Visualizar Resultados dos Testes

Após a execução dos testes, o Pester gera um relatório indicando quais testes passaram ou falharam, facilitando a detecção de problemas.
