# Argumentos no Bash

## Introdução

Quando você executa um script Bash, pode passar informações adicionais para ele por meio de argumentos. Esses argumentos permitem que o script seja mais flexível e dinâmico, adaptando seu comportamento com base nas entradas fornecidas.

## Acessando Argumentos

Os argumentos passados para um script Bash são acessíveis através de variáveis especiais:

- `$0`: O nome do script.
- `$1`, `$2`, `$3`, ...: Os argumentos passados para o script. `$1` é o primeiro argumento, `$2` o segundo, e assim por diante.
- `$#`: O número total de argumentos passados para o script.
- `$@`: Todos os argumentos como uma lista (cada argumento é tratado como um valor separado).
- `$*`: Todos os argumentos como uma única string (os argumentos são concatenados em uma única string).
- `$$`: O ID do processo do script.
- `$?`: O código de retorno do último comando executado.

## Exemplo Básico

Aqui está um exemplo simples de um script que utiliza argumentos:

```bash
#!/bin/bash
echo "Nome do script: $0"
echo "Primeiro argumento: $1"
echo "Segundo argumento: $2"
echo "Número total de argumentos: $#"
```

Se você executar este script com `./meu_script.sh arg1 arg2`, a saída será:

```
Nome do script: ./meu_script.sh
Primeiro argumento: arg1
Segundo argumento: arg2
Número total de argumentos: 2
```

## Iterando sobre Argumentos

Você pode iterar sobre todos os argumentos usando um loop `for`:

```bash
#!/bin/bash
for arg in "$@"; do
    echo "Argumento: $arg"
done
```

Esse script imprimirá cada argumento em uma nova linha.

## Manipulando Argumentos com Shift

O comando `shift` é usado para deslocar os argumentos para a esquerda. Isso significa que `$2` passa a ser `$1`, `$3` passa a ser `$2`, e assim por diante. Isso é útil quando você precisa processar um argumento por vez.

```bash
#!/bin/bash
while [ $# -gt 0 ]; do
    echo "Processando argumento: $1"
    shift
done
```

Neste script, `shift` move os argumentos para a esquerda até que não haja mais argumentos para processar (`$#` se torne 0).

## Argumentos Nomeados

Embora o Bash não suporte argumentos nomeados diretamente, você pode simular esse comportamento usando `case` e `shift` para processar argumentos.

```bash
#!/bin/bash

while [ $# -gt 0 ]; do
  case "$1" in
    -a|--argumento1)
      valor_argumento1="$2"
      shift 2
      ;;
    -b|--argumento2)
      valor_argumento2="$2"
      shift 2
      ;;
    *)
      echo "Opção desconhecida: $1"
      exit 1
      ;;
  esac
done

echo "Argumento 1: $valor_argumento1"
echo "Argumento 2: $valor_argumento2"
```

Se você executar este script com `./meu_script.sh -a valor1 -b valor2`, ele imprimirá:

```
Argumento 1: valor1
Argumento 2: valor2
```

## Utilizando Flags Booleanas

Muitas vezes, scripts precisam processar flags que ativam ou desativam certas funcionalidades.

```bash
#!/bin/bash

flag_ativado=false

while [ $# -gt 0 ]; do
  case "$1" in
    -f|--flag)
      flag_ativado=true
      shift
      ;;
    *)
      echo "Opção desconhecida: $1"
      exit 1
      ;;
  esac
done

if [ "$flag_ativado" = true ]; then
  echo "Flag foi ativada!"
else
  echo "Flag não foi ativada."
fi
```

Neste caso, se você executar `./meu_script.sh --flag`, a saída será `Flag foi ativada!`.

## Verificando Se um Argumento Foi Fornecido

Você pode verificar se um argumento específico foi fornecido verificando o valor da variável correspondente ou o número total de argumentos.

```bash
#!/bin/bash

if [ -z "$1" ]; then
  echo "Nenhum argumento fornecido!"
  exit 1
else
  echo "Primeiro argumento: $1"
fi
```

Aqui, `-z` verifica se a string está vazia.

Outra forma de fazer isso é 

```bash
#!/bin/bash

if [ $1 == "" ]
then 
	echo "Host Exploiter"
	echo "Use Mode: $0 192.168.0.20 80"
else
	echo "Exploiting host: $1 on port $2"
```
## Argumentos e Segurança

Ao lidar com argumentos, especialmente aqueles que podem conter caracteres especiais ou espaços, é importante usar aspas para garantir que sejam tratados como um único argumento.

**Exemplo problemático:**

```bash
echo $1
```

Se `$1` contiver um espaço, ele será tratado como dois argumentos diferentes. Para evitar isso, use:

```bash
echo "$1"
```
